import n from"events";var r=class extends n{constructor(s=1){super();this.size=s,this.available=s,this.tasks=[],this.queue=[],this.resolves=[],this.results=[]}on(s,e){return super.on(s,e),this}once(s,e){return super.once(s,e),this}removeListener(s,e){return super.removeListener(s,e),this}removeAllListeners(s){return super.removeAllListeners(s),this}emit(s,...e){return super.emit(s,...e)}push(s){this.tasks.push(async()=>s())}async go(){this.emit("pool-start"),this.available=this.size,this.queue=[],this.resolves=[],this.results=[];for(let s=0;s<this.tasks.length;s++)await this.isAvailable(),this.queue.push((async()=>{var e,i;this.emit("task-start",s);try{let t=await this.tasks[s]();this.results[s]=t,this.resolves.length>0&&((e=this.resolves.shift())==null||e(!0)),this.emit("task-finish",s,t)}catch(t){this.resolves.length>0&&((i=this.resolves.shift())==null||i(!0)),this.emit("task-error",s,t)}})());return await Promise.all(this.queue),this.queue=[],this.emit("pool-end"),this.results}run(){return this.go()}isAvailable(){return new Promise(s=>{this.available>0?(this.available--,s(!0)):this.resolves.push(s)})}},a=r;export{r as Pool,a as default};
